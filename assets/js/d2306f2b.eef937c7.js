"use strict";(self.webpackChunksilta_docs=self.webpackChunksilta_docs||[]).push([[200],{5619:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"ssl_certificates","title":"ssl_certificates","description":"Basics","source":"@site/docs/ssl_certificates.md","sourceDirName":".","slug":"/ssl_certificates","permalink":"/silta/docs/ssl_certificates","draft":false,"unlisted":false,"editUrl":"https://github.com/wunderio/silta/tree/master/docs/ssl_certificates.md","tags":[],"version":"current","frontMatter":{}}');var i=s(4848),c=s(8453);const r={},o=void 0,a={},l=[{value:"Basics",id:"basics",level:2},{value:"PFX to PEM",id:"pfx-to-pem",level:2},{value:"SSL certificate verification",id:"ssl-certificate-verification",level:2},{value:"Steps to test SSL certificate on Development cluster",id:"steps-to-test-ssl-certificate-on-development-cluster",level:4},{value:"Tips",id:"tips",level:2}];function d(e){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"basics",children:"Basics"}),"\n",(0,i.jsxs)(t.p,{children:["Full chain consists of 3 parts.",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"End-Entity (Server) Certificate:"})," This is your server's SSL/TLS certificate, also known as the end-entity certificate. It is the certificate that identifies your server's domain.",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"Intermediate Certificates:"})," These are the certificates of intermediate Certificate Authorities (CAs) that form the chain between your end-entity certificate and the root CA certificate. Intermediate certificates help build the trust chain between your certificate and a root CA. They are necessary because root CA certificates are typically not distributed widely due to security reasons.",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"Root CA Certificate:"})," This is the certificate of the root Certificate Authority. This certificate is the ultimate trust anchor in the chain. The root CA certificate establishes trust in the entire chain."]}),"\n",(0,i.jsx)(t.p,{children:"You can have multiple Intermediate Certificates in chain."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"exposeDomains:\n  example-customcert:\n    hostname: ssl-custom.example.com\n    ssl:\n      enabled: true\n      issuer: custom\n      key: |\n        -----BEGIN RSA PRIVATE KEY-----\n        <KEY>\n        -----END RSA PRIVATE KEY-----\n      crt: |\n        -----BEGIN CERTIFICATE-----\n        < DOMAIN CERTIFICATE >\n        -----END CERTIFICATE-----\n        -----BEGIN CERTIFICATE-----\n        < INTERMEDIATE CERTIFICATE 1 >\n        -----END CERTIFICATE-----\n        -----BEGIN CERTIFICATE-----\n        < INTERMEDIATE CERTIFICATE 2 >\n        -----END CERTIFICATE-----\n        -----BEGIN CERTIFICATE-----\n        < INTERMEDIATE CERTIFICATE N >\n        -----END CERTIFICATE-----        \n        -----BEGIN CERTIFICATE-----\n        < ROOT CA CERTIFICATE >\n        -----END CERTIFICATE-----\n"})}),"\n",(0,i.jsx)(t.h2,{id:"pfx-to-pem",children:"PFX to PEM"}),"\n",(0,i.jsxs)(t.p,{children:["Extraction (legacy flag is required if older version of PKCS#12 was used to create PFX file):",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"openssl pkcs12 -legacy -in custom_cert.pfx -nocerts -nodes | sed -ne '/-BEGIN PRIVATE KEY-/,/-END PRIVATE KEY-/p' > private.key"}),(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"openssl pkcs12 -legacy -in custom_cert.pfx -cacerts -nokeys -chain | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > ca.crt"}),(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"openssl pkcs12 -legacy -in custom_cert.pfx -clcerts -nokeys | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > domain.crt"})]}),"\n",(0,i.jsxs)(t.p,{children:["Creating full chain:\n",(0,i.jsx)(t.code,{children:"cat domain.crt ca.crt > fullchain.crt"})]}),"\n",(0,i.jsxs)(t.p,{children:["You can also use ",(0,i.jsx)(t.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:s(6377).A+"",children:"this script"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"ssl-certificate-verification",children:"SSL certificate verification"}),"\n",(0,i.jsxs)(t.p,{children:["You can verify full chain part:",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"openssl verify -CAfile fullchain.crt domain.crt"}),(0,i.jsx)(t.br,{}),"\n","And then matching with private key",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"openssl x509 -noout -modulus -in fullchain.crt | openssl md5"}),(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"openssl rsa -noout -modulus -in private.key | openssl md5"}),(0,i.jsx)(t.br,{}),"\n","Output values should match."]}),"\n",(0,i.jsxs)(t.p,{children:["Testing certificate on live server can be done only on different cluster/environment.\n",(0,i.jsx)(t.em,{children:"!NB Do not try to test it on Production cluster/environment where production hostname is in use already."})]}),"\n",(0,i.jsx)(t.h4,{id:"steps-to-test-ssl-certificate-on-development-cluster",children:"Steps to test SSL certificate on Development cluster"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Make a new Git branch"}),"\n",(0,i.jsxs)(t.li,{children:["Add SSL certificates domain to Exposed domains in ",(0,i.jsx)(t.code,{children:"stila.yml"})]}),"\n",(0,i.jsx)(t.li,{children:"Create secrets file, put relevant structure and encrypt it with cluster's secret key"}),"\n",(0,i.jsxs)(t.li,{children:["Modify ",(0,i.jsx)(t.code,{children:".circleci/config.yml"})," to decrypt secret and use it in ",(0,i.jsx)(t.code,{children:"silta_config"})," part"]}),"\n",(0,i.jsx)(t.li,{children:"Push branch to trigger deployment"}),"\n",(0,i.jsxs)(t.li,{children:["Verify SSL certificate with ",(0,i.jsx)(t.code,{children:"openssl s_client -connect [IP]:443 -servername [hostname]"}),". Expected result",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"SSL handshake has read 7583 bytes and written 408 bytes Verification: OK"}),". If something is wrong You'll get",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"Verification error: unable to verify the first certificate"})," and/or ",(0,i.jsx)(t.code,{children:"Verify return code: 21 (unable to verify the first certificate)"})]}),"\n",(0,i.jsxs)(t.li,{children:["You can also change ",(0,i.jsx)(t.code,{children:"/etc/hosts"})," to resolve hostname and verify SSL certificate via browser"]}),"\n",(0,i.jsx)(t.li,{children:"When everything looks good delete the testing branch and proceed with production release."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"tips",children:"Tips"}),"\n",(0,i.jsxs)(t.p,{children:["PEM strings can be encoded in different formats. Both cases are valid",(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"-----BEGIN RSA PRIVATE KEY-----"}),(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"-----BEGIN PRIVATE KEY-----"}),(0,i.jsx)(t.br,{}),"\n",(0,i.jsx)(t.code,{children:"openssl"})," will take care of correct decoding. ",(0,i.jsx)(t.a,{href:"https://git.openssl.org/?p=openssl.git;a=blob;f=include/openssl/pem.h;hb=HEAD#l35",children:"List of all supported formats"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},6377:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/files/pfx-ready-ecdc2d70ae99d08a03d552fa94262a35.sh"},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var n=s(6540);const i={},c=n.createContext(i);function r(e){const t=n.useContext(c);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(c.Provider,{value:t},e.children)}}}]);